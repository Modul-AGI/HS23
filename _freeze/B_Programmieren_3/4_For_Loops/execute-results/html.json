{
  "hash": "a01a08dff0f69e49d57fa30c07b73d31",
  "result": {
    "markdown": "# Aufgabe 12: *for loops* Advanced {#sec-forloops-3}\n\n## Theorie\n\nIn diesem Kapitel kommen noch zwei Aspekte von *for loops*, die als \"*Advanced*\" eingestuft werden können aber in der Praxis sehr nützlich sind. Dabei geht es einerseits um verschachtelte *for loops* und zum andere um eine verkürzte Schreibweise von *for loops*. \n\n### Verschachtelte *for loops*\n\nWir können verschiedene *for loops* auch ineinander verschachteln (englisch: *nested loops*). Das ist vor allem dann nützlich, wenn alle Kombinationen aus zwei Datensätzen miteinander verrechnet werden müssen. Angenommen du willst die drei Mitglieder deiner Band (bestehend aus *Il Buono*, *Il Brutto*, *Il Cattivo*) deinen Eltern vorstellen und auch umgekehrt deine Eltern deiner Band vorstellen. Für so was eignen sich zwei verschachtelte *for Loops* hervorragend:\n\n:::{.callout-note collapse=\"true\"}\n\nAls Platzhaltervariabel nutze ich wenn immer möglich das Singulär und für den Iterator das Plural von dem Objekt, über das ich iteriere. `for bandmitglied in band`, `for vogel in voegel` usw, dies hilft mir den Überblick im *loop* zu bewahren.\n:::\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\neltern = [\"Papa\", \"Mama\"]\nband = [\"Il Buono\", \"Il Brutto\", \"Il Cattivo\"]\n\nfor bandmitglied in band:\n    for elternteil in eltern:\n        print(elternteil, \"das ist\",bandmitglied)\n        print(bandmitglied, \"das ist\",elternteil)\n        print(\"---\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPapa das ist Il Buono\nIl Buono das ist Papa\n---\nMama das ist Il Buono\nIl Buono das ist Mama\n---\nPapa das ist Il Brutto\nIl Brutto das ist Papa\n---\nMama das ist Il Brutto\nIl Brutto das ist Mama\n---\nPapa das ist Il Cattivo\nIl Cattivo das ist Papa\n---\nMama das ist Il Cattivo\nIl Cattivo das ist Mama\n---\n```\n:::\n:::\n\n\n:::{.callout-note collapse=\"true\"}\n\nEin anderes Beispiel:  In @sec-forloops-ex-party haben wir die beiden Zeilen `\"Who likes to party?\"`, \"We like to party?\" 5x wiederholt. Dabei werden die Wörter `to party für jede Wiederholung zwei mal wiederholt:\n\n```\nWho likes to party?\nWe like to party!\nWho likes to party?\nWe like to party!\n...\n\n```\n\n\nDies kann man in zwei verschachtelte *For Loops* umschreiben:\n\n```python\nfor i in range(5):\n    inner = [\"Who likes\", \"We like\"]\n    for j in inner:\n        print(j+\" to party\")\n\nWho likes to party\nWe like to party\nWho likes to party\nWe like to party\n\n```\n\n:::\n\n### Verkürzte Schreibweise\n\nEs ist äusserst häufig der Fall, dass wir den Output aus einem Loop in einer Liste abspeichern wollen. Wie das geht haben wir ja bereits in @sec-forloops-2 gelernt:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nrollen = [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]\n\nrefrain = []\nfor rolle in rollen:\n    liedzeile = \"I'm a \"+ rolle \n    refrain.append(liedzeile)\n```\n:::\n\n\nNur ist das ein *bisschen* umständlich, weil wir dafür viele Zeilen Code brauchen, um etwas eigentlich ganz simples zu bewerkstelligen. Es gibt deshalb dafür auch eine verkürzte Schreibweise, welche ich in der letzten Woche bereits einmal verwendet habe (siehe @sec-offset-vis). Der obige Loop hat in der verkürzten Schreibweise die folgende Form:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nrefrain = [\"I'm a \"+ rolle for rolle in rollen]\n```\n:::\n\n\nDiese verkürzte Schreibweise heisst in Python *list comprehension* und sie ist äusserst praktisch, wenn man sie beherrscht. Das Beherrschen ist aber nicht zentral, es reicht schon wenn ihr eine solche Schreibweise wieder erkennt und richtig interpretieren könnt (im Sinne von \"*Aha, hier wird also in einem Loop eine Liste erstellt*\"). In der folgenden Darstellung seht ihr farblich, welche Elemente sich in der verkürzten Schreibweise wo wiederfinden und welche Elemente gar nicht wiederverwendet werden.\n\n\n<pre>rollen = [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]</pre>\n\n\n````{panels}\nHerkömmlicher For-Loop:\n^^^\n<pre class = \"showcol\">\n<span class = \"grp1\">refrain =</span> <span class = \"grp2\">[]</span>\n<span class = \"grp3\">for</span> <span class = \"grp4\">ro in rollen</span>:\n    <del>liedzeile =</del> <span class = \"grp5\">\"I'm a \"+ ro</span>\n    <del>refrain.append(liedzeile)</del>\n</pre>\n---\nVerkürzte Schreibweise:\n^^^\n<pre class = \"showcol\">\n<span class = \"grp1\">refrain =</span> <span class = \"grp2\">[</span><span class = \"grp5\">\"I'm a \"+ ro</span> <span class = \"grp3\">for</span> <span class = \"grp4\">ro in rollen</span><span class = \"grp2\">]</span>\n</pre>\n````\n\n\n## Übungen\n\n### Übung 12.1\n\nErstelle zwei Listen bestehend aus 3 Hundenamen (`hunde`) und 3 Katzennamen (`katzen`). Erstelle einen verschachtelten *For Loop*, wo jeder Hund jede Katze beisst und jede Katze jeden Hund kratzt.\n\n```python\nBruno beisst Greta und Greta kratzt  Bruno\nBerta beisst Greta und Greta kratzt  Berta\nHelmi beisst Greta und Greta kratzt  Helmi\n....\n```\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nhunde = [\"Bruno\", \"Berta\",\"Helmi\"]\nkatzen = [\"Greta\", \"Xavier\", \"Zachy\"]\n\nfor katze in katzen:\n    for hund in hunde:\n        print(hund, \"beisst\", katze+\" und \"+katze, \"kratzt \", hund)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBruno beisst Greta und Greta kratzt  Bruno\nBerta beisst Greta und Greta kratzt  Berta\nHelmi beisst Greta und Greta kratzt  Helmi\nBruno beisst Xavier und Xavier kratzt  Bruno\nBerta beisst Xavier und Xavier kratzt  Berta\nHelmi beisst Xavier und Xavier kratzt  Helmi\nBruno beisst Zachy und Zachy kratzt  Bruno\nBerta beisst Zachy und Zachy kratzt  Berta\nHelmi beisst Zachy und Zachy kratzt  Helmi\n```\n:::\n:::\n\n\n<!-- % !!ENTFERNT! -->\n\n<!-- % Nested Loop: Multiplikation -->\n### Übung 12.2 (Optional)\n\nErstelle einen verschachtelten Loop, wo alle Kombinationen von 0 bis 9 miteinander addiert werden:\n\n```python\n\n\naddition = []\nwerte = range(10)\nfor i in werte:\n    for j in werte:\n        resultat = i+j\n        addition.append(resultat)\n```\n\n### Übung 12.2 (fakultativ, für Fortgeschrittene!)\n\nVersuche die Monte Carlo Simulation für die Annäherung an Pi (aus der ersten Übung \"Datenqualität und Unsicherheit) mit einer Funktion und einem For Loop zu lösen.\n\nZur Erinnerung, die Vorgehensweise für die Annäherung an Pi geht folgendermassen:\n\n1. Zufallskoordinaten (`x`, `y`) zwischen 0 und 1 erstellen\n2. Distanz zum Ursprung (0) mit der Formel $\\sqrt(x^2+y^2)$ berechnen\n3. Bestimmen ob sich der Punkt innerhalb des Kreisviertels befindet ($d < 1$)\n4. Schritte 1 & 2 mehrfach wiederholen\n5. Anteil der Punkte *innerhalb* des Kreisviertels mit 4 Multiplizieren\n\nTipps:\n\n- Für die Erstellung der Zufallspunkte brauchst du die Funktion `random()` aus dem modul `random`\n- Schritte 1 - 3 werden am sinnvollsten ein eine Funktion verpakt, welche keine Argumente benötigt\n- Schritt 4 löst du am besten mit einer `For loop` mit `range(100)` (für 100 Wiederholungen)\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport random\ndef get_pi(): \n    x = random.random()\n    y = random.random()\n    pythagoras = (x**2+y**2)**0.5\n    return pythagoras>1\n\nget_pi()\n\nres = [get_pi() for x in range(1000000)]\n\n(len(res)-sum(res))/len(res)*4\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n3.139708\n```\n:::\n:::\n\n\n",
    "supporting": [
      "4_For_Loops_files"
    ],
    "filters": [],
    "includes": {}
  }
}