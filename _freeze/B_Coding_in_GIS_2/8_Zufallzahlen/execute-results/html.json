{
  "hash": "a70c57cf7934b04a81aa967ef9ef2b65",
  "result": {
    "markdown": "# Aufgabe 8: Zufallszahlen generieren {#sec-random-numbers}\n\n## Theorie\n\nIm Block \"*Datenqualität und Unsicherheit*\" habt ihr euch bereits mit Zufallszahlen und Simulationen auseinandergesetzt. Programmiersprachen sind für eine solche Anwendung sehr gut geeignet, und deshalb werden wir in diesem Abschnitt eine Erweiterung zur Erstellung von Zufallszahlen kennenlernen. Diese Erweiterung lautet `random` und ist Teil der [\"Python Standard Library\"](https://en.wikibooks.org/wiki/Python_Programming/Standard_Library), was bedeutet das dieses Erweiterung bereits installiert ist, und wir sie nicht installieren müssen. \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport random\n```\n:::\n\n\n::: {.cell tags='[\"remove-cell\"]' execution_count=2}\n``` {.python .cell-code}\nrandom.seed(2)\n```\n:::\n\n\nInnerhalb vom `random` gibt es zahlreiche Funktionen um Zufallszahlen zu generieren, je nachdem was unsere Anforderungen an die Zufallszahl ist. Eine Anforderung könnte zum Beispiel sein, dass die Zahl innerhalb eines bestimmten Bereichs luegen soll (z.B. \"*generiere eine Zufallszahl zwischen 1 und 9*\"). Oder aber, dass sie eine ganze Zahl sein muss. Weiter könnte die Anforderung sein, dass sie aus einer bestimmten Verteilung kommen sollte, zum Beispiel einer Normalverteilung. In diesem letzten Fall müssen wir den Mittlwert sowie die Standartabweichung unserer Verteilung angeben.\n\nUm eine ganzzahlige Zufallszahl zwischen 1 und 9 zu generieren, können wir die Funktion `randrange()` nutzen:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nrandom.randrange(start = 1, stop = 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1\n```\n:::\n:::\n\n\nWenn wir auf diese Weise mit `randrange()` immer wieder neue Zufallszahlen generieren fällt auf, dass die Verteilung der Zahlen ziemlich gleichmässig ist. Es ist also gleich wahrscheinlich eine 9 zu bekommen eine eine 1 oder eine 5. Die Zahlen kommen also aus einer \"uniformen\" Verteilung. Um dies zu verdeutlichen generiere ich in den folgenden Codezeilen 100 Zufallszahlen zwischen 1 und 9 mit der Funktion `randrange` und visualisiere die Häufigkeit der einzelnen Zahlen in einem Histogramm. \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# erstellt eine Liste von Zufallszahlen (lernen wir zu einem späteren Zeitpunkt)\na = [random.randrange(1, 10) for x in range(100)]\n\nimport pandas as pd\n\n# visualisiert die zufällig generierten Zahl in Form eines Histogramms (lernen wir ebenfalls später)\npd.Series(a).plot(kind = \"hist\", bins = range(1, 11), edgecolor = \"black\", align = \"left\", xticks = range(1, 10))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n<AxesSubplot:ylabel='Frequency'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](8_Zufallzahlen_files/figure-html/cell-5-output-2.png){width=597 height=404}\n:::\n:::\n\n\nDie Funktion `randrange()` generiert nur ganzzahlige Zufallszahlen. Wenn wir aber eine Zufallszahl mit Nachkommastellen brauchen, verwenden wir die Funktion `uniform()`. \n\nUm Zufallszahlen aus einer \"Normalverteilung\" zu erhalten, verwenden wir die Funktion `normalvariate`. Hier müssen wir den Mittelwert und die Standartabweichung dieser Verteilung angeben. Tatsächlich können wir bei dieser Variante keine Minimum- und Maximumwerte festlegen: Theoretisch könnte der Generator jeden erdenklichen Zahlenwert rausspucken, am wahrscheinlichsten ist jedoch eine Zahl nahe am angegebenen Mittelwert.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# mu = Mittelwert, sigma = Standartabweichung\nrandom.normalvariate(mu = 5, sigma = 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2.6231634045105694\n```\n:::\n:::\n\n\nWenn wir die obige Funktion 10'000x laufen lassen und uns das Histogramm der generierten Zahlen anschauen, dann zeichnet sich folgendes Bild ab. \n\n::: {.cell tags='[]' execution_count=6}\n``` {.python .cell-code}\nb = [random.normalvariate(mu = 5, sigma = 2) for b in range(10000)]\npd.Series(b).plot(kind = \"hist\", bins = 30, edgecolor = \"black\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<AxesSubplot:ylabel='Frequency'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](8_Zufallzahlen_files/figure-html/cell-7-output-2.png){width=602 height=404}\n:::\n:::\n\n\n## Übungen\n\nNun wollen wir diesen Zufallszahlengenerator `random` nutzen um eine Funktion zu entwickeln, welche einen beliebigen Punkt (mit einer x-/y-Koordinate) zufällig in einem definierten Umkreis verschiebt. Unser Fernziel ist es, den simulierten Datensatz aus  \"Datenqualität und Unsicherheit\" zu rekonstruieren (siehe unten). Der erste Schritt dorthin ist es, einen gemeldeten Punkt (rot in @fig-arcgiszecken) in einem definierten Umkreis zu verschieben.\n\n![Ausschnitt der simulierten Zeckenstiche. Der rote Punkt stellt jeweils den gemeldeten Zeckenstich dar, die blaue Punktwolke drum herum sind simulierte Punkte welche die Ungenauigkeit der Daten wiederspiegelt.](figures/arcgiszecken.jpg){#fig-arcgiszecken}\n\n\nDas Ziel dieser Übung ist es also, dass wir eine Funktion entwickeln, die uns einen zufälligen Punkt in der Nähe eines Ursprungspunktes vorschlägt. Unser Vorgehen: Wir addieren jedem Koordinatenwert (`x`/`y`) des Ursprungspunktes einen Zufallswert, zum Beispiel zwischen -100 bis +100.\n\n<!-- % Zufallszahlen aus Uniformverteilung -->\n### Übung 8.1\n\nBevor wir mit Koordinaten arbeiten wollt ihr euch zuerst mit dem Modul `random` vertraut machen. Importiere das Modul `random` und generiere eine Zufallszahl zwischen -100 und +100 aus einer uniformen Verteilung sowie aus einer Normalverteilung mit Mittelwert 100 und Standartabweichung 20.\n\n::: {.cell tags='[\"hide-cell\"]' execution_count=7}\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n105.15246738773395\n```\n:::\n:::\n\n\n<!-- % Dummykoordinaten erstellen -->\n### Übung 8.2\n\nNun wollen wir uns den Koordinaten zuwenden. Erstelle als erstes zwei Dummykoordinaten `x_start` und `y_start` mit jeweils dem Wert `0`. Diese sollen als \"Ursprungskoordinaten\" dienen.\n\n\n\n<!-- % : Zufallswerte generieren -->\n### Übung 8.3\n\nGeneriere nun eine Zufallszahl, die aus einer Normalverteilung stammt und die *in etwa* zwischen -100 und +100 liegt. Weise diese Zahl der Variabel `x_offset` zu.\nGeneriere danach eine zweite Zufallszahl (auf die gleiche Art) und weise diese `y_offset` zu.\n\n\n:::{.callout-note collapse=\"true\"}\n\nÜberlege dir, welcher *Mittelwert* Sinn macht um Werte zwischen -100 und +100 zu bekommen. Welche Zahl liegt zwischen -100 und +100?\n\nÜberlege dir als nächstes, welche Standartabweichung sinnvoll wäre. Zur Erinnerung: Etwa 68% der Werte liegen inerhalb von +/- 1 Standartabweichung (SD), 95% innerhalb von +/- 2 SD, 99% innerhalb von 3 SD (siehe unten):\n\n\n![](figures/normalverteilung.jpg)\nNormalverteilung und die Anteile innerhalb von 1 Standartabweichung (Mittelwert $\\mu$ minus Standartabweichung $\\sigma$), 2 Standartabweichungen ($\\mu - 2\\times\\sigma)$ und 2 Standartabweichungen ($\\mu - 3\\times\\sigma)$. Quelle: [cobocards](https://www.cobocards.com/)\n```\n:::\n\n::: {.cell tags='[\"hide-cell\"]' execution_count=9}\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n-49.84550284501804\n```\n:::\n:::\n\n\n<!-- % : Zufallswerte addieren -->\n### Übung 8.4\n\nAddiere nun die Zufallszahlen `x_offset` und `y_offset` **jeweils** zu den Dummykoordinaten `x_start` und `y_start` und weise diese neuen Koordinaten `x_neu` und `y_neu` zu. Die neuen Werte stellen die leicht verschobenen Ursprungskoordinaten dar. In meinem Fall sind diese um 10.2 Meter nach Osten (positiver Wert) bzw. 4.4 Meter nach Süden (negativer Wert) verschoben worden.\n\n::: {.cell tags='[\"remove-cell\"]' execution_count=10}\n``` {.python .cell-code}\nx_offset = 10.246170309600945\ny_offset = -4.443904000288846\n```\n:::\n\n\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nx_neu\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n10.246170309600945\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ny_neu\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n-4.443904000288846\n```\n:::\n:::\n\n\nUm den Output zu visualisieren, kreiere ich aus den Einzelwerten einen *pandas DataFrame*:\n\n::: {.cell tags='[]' execution_count=14}\n``` {.python .cell-code}\nmypoints = pd.DataFrame({\n    \"x\":[x_start, x_neu], \n    \"y\": [y_start, y_neu],\n    \"typ\": [\"urprung\", \"neu\"]\n    })\nmypoints\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n      <th>typ</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.00000</td>\n      <td>0.000000</td>\n      <td>urprung</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>10.24617</td>\n      <td>-4.443904</td>\n      <td>neu</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=15}\n``` {.python .cell-code}\nfrom matplotlib import pyplot as plt\n\nmypoints.plot(\"x\", \"y\", kind = \"scatter\", xlim = [-100, 100], ylim = [-100, 100], c = [\"red\", \"blue\"], title = \"Ursprung (rot) und Simulation (blau)\")\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n<AxesSubplot:title={'center':'Ursprung (rot) und Simulation (blau)'}, xlabel='x', ylabel='y'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](8_Zufallzahlen_files/figure-html/cell-16-output-2.png){width=617 height=442}\n:::\n:::\n\n\n<!-- % : Arbeitsschritte in eine *Function* verwandeln -->\n### Übung 8.5 {#sec-ex-offset-function}\n\nNun haben wir das zufällige Verschieben eines Einzelpunktes am Beispiel einer Dummykoordinaten (`0`/`0`) durchgespielt. In der nächsten Aufgabe (@sec-offset-dataframe) werden wir *alle* unsere Zeckenstichkoordinaten auf diese Weise zufällig verschieben um einen simulierten Zeckenstichdatensatz ähnlich wie @fig-arcgiszecken zu erhalten. \n\nDafür brauchen wir die eben erarbeiteten Einzelschritte als Funktion, um diese auf alle Zeckenstiche anwenden zu können. **Erstelle jetzt eine Funktion namens `offset_coordinate` welche als Input eine `x` oder `y`-Achsenwert annimmt und eine leicht verschobene Wert zurückgibt.** Integriere die Standartabweichung der Verteilung als optionalen Parameter mit dem Namen `distance` und einem Defaultwert von 100.\n\n::: {.cell tags='[\"hide-cell\"]' execution_count=16}\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n16.79159802370436\n```\n:::\n:::\n\n\n<!-- % : Output visualisieren -->\n### Übung 8.6 {#sec-offset-vis}\n\nNun ist es wichtig, dass wir unser Resultat visuell überprüfen. Im Beispiel unten wende ich die in der letzten Übung erstellte Funktion `offset_coordinate()` 1'000 mal auf die Dummykoordinate an. Nutze *deine* Funktion `offset_coordinate` um eine Visualisierung gemäss untenstehendem beispiel zu machen.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nx_neu_list = [offset_coordinate(x_start, 100) for i in range(1, 1000)]\ny_neu_list = [offset_coordinate(y_start, 100) for i in range(1, 1000)]\n\n# Liste in eine Pandas DataFrame überführen\nmysim = pd.DataFrame({\"x\" : x_neu_list, \"y\" : y_neu_list})\n\nmysim.plot(\"x\", \"y\", kind = \"scatter\")\n\nfrom matplotlib import pyplot as plt\nplt.axis(\"equal\")\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n(-318.5597408142399, 303.6705172410597, -412.3186754259741, 388.57577848318084)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](8_Zufallzahlen_files/figure-html/cell-18-output-2.png){width=604 height=422}\n:::\n:::\n\n\n",
    "supporting": [
      "8_Zufallzahlen_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}