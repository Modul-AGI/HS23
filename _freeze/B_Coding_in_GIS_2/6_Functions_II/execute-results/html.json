{
  "hash": "b65994ae329b331214e82c75d2863fec",
  "result": {
    "markdown": "# Aufgabe 6: *Function* Advanced {#sec-function-advanced}\n\n## Theorie\n\n### Standart-Werte\n\nMan kann für einzelne (oder alle) Parameter auch Standardwerte festlegen. Das sind Werte die dann zum Zug kommen, wenn der Nutzer der Funktion das entsprechende Parameter leer lässt. Schauen wir dazu nochmals `sag_hallo()` an.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname + \"!\" \n```\n:::\n\n\nUm diese Funktion zu nutzen muss dem Parameter `vorname` ein Argument übergeben werden, sonst erhalten wir eine Fehlermeldung. \n\n::: {.cell tags='[\"raises-exception\"]' execution_count=2}\n``` {.python .cell-code}\nsag_hallo()\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: sag_hallo() missing 1 required positional argument: 'vorname'\n```\n:::\n:::\n\n\nWenn wir möchten, dass gewisse Parameter auch ohne Argument auskommen, dann könnnen wir einen Standartwert festlegen. So wird der Parameter optional. Bespielsweise könnte `sag_hallo()` einfach *Hallo Du!* zurückgeben, wenn kein Vorname angegeben wird. Um dies zu erreichen, definieren wir den Standartwert bereits innerhalb der Klammer, und zwar folgendermassen:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef sag_hallo(vorname = \"Du\"):\n    return \"Hallo \" + vorname + \"!\" \n\n# Wenn \"vorname\" nicht angegeben wird:\nsag_hallo()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'Hallo Du!'\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n## Wichtig\n\nWenn mehrere Parameter in einer Funktion definiert werden, dann kommen die optionalen Parameter **immer zum Schluss**.\n:::\n\n### Reihenfolge der Argumente\n\nWenn die Argumente in der gleichen Reihenfolge eingegeben werden, wie sie in der *Function* definiert sind, müssen die Parameter **nicht** spezifiziert werden (z.B: `anrede=`, `nachname=`).\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef gruezi2(nachname, anrede):\n    return \"Guten Tag, \" + anrede + \" \"+nachname\n\ngruezi2(\"van Rossum\", \"Herr\")\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n'Guten Tag, Herr van Rossum'\n```\n:::\n:::\n\n\nWenn wir die Reihenfolge missachten, ist der Output unserer Funktion fehlerhaft:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ngruezi2(\"Herr\", \"van Rossum\")\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'Guten Tag, van Rossum Herr'\n```\n:::\n:::\n\n\nAber wenn die Parameter der Argumente spezifiziert werden, können wir sie in jeder beliebigen Reihenfolge auflisten:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ngruezi2(anrede = \"Herr\", nachname = \"van Rossum\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'Guten Tag, Herr van Rossum'\n```\n:::\n:::\n\n\n### Funktionen auf mehreren Zeilen\n\nBisher waren unsere Funktionen sehr kurz und einfach und wir benötigten dafür immer nur zwei Zeilen: Die erste Zeile begann die *Function*-Definition (`def..`) und die zweite Zeile retournierte bereits die Lösung `return(...)`. \n\nZwischen diesen beiden Komponenten haben wir aber viel Platz, den wir uns zu Nutze machen können. Wir können hier Kommentare hinzufügen wie auch unsere Funktion in Einzelschritte aufteilen um den Code lesbarer zu machen.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef gruezi2(nachname, anrede):\n    \"\"\" \n    Meine coole Grüezi funktion\n    Diese Funktion soll Menschen freundlich grüssen. \n    Sie nimmt zwei Inputs: nachname und andrede, beides \"strings\"\n    \"\"\"\n    gruss = \"Guten Tag, \" + anrede + \" \"+nachname\n    return gruss\n```\n:::\n\n\nAllgemeine Kommentare werden in Python mit `#` hinzugefügt, Funktionen werden aber mit drei Anführungs- und Schlusszeichen kommentiert. Diese Kommentare erscheinen eleganterweise wenn man die Hilfe zu dieser Funktion mit `help()` aufruft:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nhelp(gruezi2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on function gruezi2 in module __main__:\n\ngruezi2(nachname, anrede)\n    Meine coole Grüezi funktion\n    Diese Funktion soll Menschen freundlich grüssen. \n    Sie nimmt zwei Inputs: nachname und andrede, beides \"strings\"\n\n```\n:::\n:::\n\n\n### Globale und Lokale Variabeln\n\nInnerhalb einer *Function* können nur die Variabeln verwendet werden, die der *Function* als Argumente übergeben (oder innerhalb der Funktion erstellt) werden. Diese nennt man \"lokale\" Variabeln und sind nur lokal in der *Function* vorhanden. Im Gegensatz dazu stehen \"globale\" Variabeln, welche Teil der aktuellen Session sind. \n\nVersuchen wir das mit einem Beispiel zu verdeutlichen. Angenommen wir definieren gobal die Variabel `vorname`:\n\n::: {.cell tags='[\"raises-exception\"]' execution_count=9}\n``` {.python .cell-code}\n# Wir definieren globale Variabel\nvorname = \"Guido\"\n\n# Nun erstellen wir eine Function, welche diese Variabel (\"vorname\") nutzen soll:\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname\n\n# Wenn wir jetzt aber die Function ausführen wollen, entsteht die Fehlermeldung,\n# dass \"vorname\" fehlt (obwohl wir vorname ja schon definiert haben)\nsag_hallo()\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: sag_hallo() missing 1 required positional argument: 'vorname'\n```\n:::\n:::\n\n\n### Lambda-Function {#sec-functions-lambda}\n\nMit dem Begriff `lambda` kann eine *Function* verkürzt geschrieben werden. Wir werden dies im Unterricht kaum verwenden, es ist aber doch gut davon gehört zu haben. Nachstehend wird die Funktion `sag_hallo()` in der bekannten, wie auch in der verkürzten Form definiert. \n\n\n:::: columns\n\n::: {.column width=\"50%\"}\n\nHerkömmliche Weise:\n\n```python\ndef sag_hallo(vorname):\n    return \"Hi \"+vorname\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\nVerkürzt mit `lambda`:\n\n```python\nsag_hallo = lambda vorname: \"Hi \"+vorname\n```\n\n:::\n\n::::\n\n\n\n\n## Übungen\n\n<!-- %: Multiplizieren -->\n### Übung 6.1\n\nErstelle eine Funktion namens `times`, die zwei Zahlen miteinander multipliziert. \n\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ntimes(2, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n4\n```\n:::\n:::\n\n\n<!-- % : Optionale Parameter -->\n### Übung 6.2\n\nDie eben erstellte Funktion `times` benötigt 2 Argumente (die miteinander multipliziert werden). Wandle den zweiten Parameter in einen optionalen Parameter um (mit dem Defaultwert `1`). \n\n**Zusatzaufgabe**: Was passiert, wenn du den ersten Parameter in einen optionalen Parameter umwandelst?\n\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ntimes(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n3\n```\n:::\n:::\n\n\n```\n#| error: false\n#| echo: false\n# Musterlösung\n# (Zusatzaufgabe)\n\ndef times(x = 1, y):\n    return x * y\n\nFile \"<ipython-input-10-e0d2091c9b0f>\", line 1\n    def times(x = 1, y):\n              ^\nSyntaxError: non-default argument follows default argument\n```\n\n<!-- % : BMI -->\n### Übung 6.3 {#sec-ex-functions-bmi}\n\nErstelle eine Funktion namens `bmi`, die aus Grösse und Gewicht einen BodyMassIndex berechnet ($BMI=\\frac{m}{l^2}$, $m$: Körpermasse in Kilogramm, $l$: Körpergrösse in Meter). Das Resultat soll etwa folgendermassen aussehen:\n\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nbmi(groesse_m = 1.8, gewicht_kg = 88)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n27.160493827160494\n```\n:::\n:::\n\n\n<!-- %  Mittelwert -->\n### Übung 6.4\n\nErstelle eine Funktion `mittelwert()`, welche den Mittelwert aus einer Liste (`List`) von Zahlen berechnet. Das Resultat sollte folgendermassen aussehen:\n\n\n:::{.callout-note collapse=\"true\"}\nNutze dazu `sum()` und `len()` analog @sec-mittelwert.\n:::\n\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nmeine_zahlen = [50, 100, 550, 1000]\nmittelwert(meine_zahlen)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n425.0\n```\n:::\n:::\n\n\n<!-- %  Grad Celsius in Farenheit -->\n### Übung 6.5\n\nErstelle eine Funktion `celsius_zu_farenheit`, welche eine beliebige Zahl von Grad Celsius in Grad Farenheit konvertiert. Zur Erinnerung: *Temperatur in °F = Temperatur in °C x 1,8 + 32*. \n\n\n\nDas Resultat sollte folgendermassen aussehen:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ncelsius_zu_farenheit(celsius = 25)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n77.0\n```\n:::\n:::\n\n\n<!-- % Lambda Function -->\n### Übung 6.6\n\nSchreibe die letzte Funktion `celsius_zu_farenheit` in der *lambda* Notation.\n\n\n\n",
    "supporting": [
      "6_Functions_II_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}